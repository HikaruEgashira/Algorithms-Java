\documentclass[10.5pt,a4paper]{jsarticle}
\usepackage{graphicx}
\usepackage{amsmath}

\usepackage[final]{listings}
\usepackage{color}

\normalsize

\lstset{
  language=fortran,
  basicstyle=\ttfamily\scriptsize,
  commentstyle={\ttfamily \color[cmyk]{0,1,1,0}},
  keywordstyle={\bfseries \color[cmyk]{1,1,0,0}},
  stringstyle={\ttfamily \color[cmyk]{1,0,1,0.5}},
  stepnumber=1,
  numberstyle=\ttfamily,
  breaklines=true,
  breakindent=20pt,
  frame=tblr,
  framesep=4pt,
  tabsize=2
}

\newcommand{\figref}[1]{図\ref{#1}}
\newcommand{\tabref}[1]{表\ref{#1}}
\newcommand{\secref}[1]{\ref{#1}節}

\title{データ構造とアルゴリズム実験レポート\\課題２：\textless 連結リスト，スタック，キュー \textgreater}
\author{\textless 201811320\textgreater \textless 1クラス\textgreater \textless 江頭輝\textgreater}
\date{締切日：\textless 2019年4月22日\textgreater\\提出日：\textless 2019年4月27日\textgreater}

\begin{document}
\maketitle

\section{必須課題2-1}

この課題では，セルに整数値を格納する連結リストを実現するクラスListをJava言語で実装する。

\subsection{List.javaの作成}
\subsubsection{実装の方針}

まず，\texttt{List}クラスを定義する。

1. コンストラクタ

セルの直後（ポインタは）`p.next`のような形で表現し、セルの値は`p.data`のように表記する。
そして、リストの最初を表すリストをheadとして定義した。

2. \texttt{insert\_cell}メゾッド

リストpの次にdを値として持つリストを挿入するので、まずデータがdのリストを作成する。
その後、pの次にそのリストが来て、その次にp.nextが来るような実装を行う。

3. \texttt{delete\_cell}メゾッド

引数として指定したリストpのポインタを表すコピーを作成して、pのポインタはpのポインタのポインタになるようにリスト関係を実装する。

4. \texttt{display}

まずheadのコピーを作成する必要がある。

5. 実装コードおよびコードの説明

\begin{figure}[t]
  \begin{center}
   \lstinputlisting[language=java,numbers=left]{List.java}
   \caption{List.javaのソースコード}
  \end{center}
\end{figure}

\subsubsection{実装の方針}
insert\_cellとinsert\_cell\_topでは即席変数であるnew\_cellを作成しそのデータに引数を渡すことで新たなセルを作成する。
topの場合はのポインタにこれまでの\texttt{head}をよび、
前者では引数として渡したのポインタがのポインタになるようにする。
delete\_cellではのポインタに\texttt{p}のポインタのポインタを代入することでセルの削除を行うようにしている。
delete\_cell\_topではではなくtexttt{head}になった。
displayではのポインタが\texttt{null}になるまで値をループで出力する。

\subsubsection{実行結果}\label{sec:ls_code_exec}

まず，List.javaを以下のコマンドでコンパイルする．

\begin{verbatim}
-------------------------------------
$ javac List.java
-------------------------------------
\end{verbatim}
コンパイル後に以下のコマンドで実行を行った。
\begin{verbatim}
-------------------------------------
$ java List
123
13
3
-------------------------------------
\end{verbatim}

\texttt{main}メゾッドでまず、1を先頭に追加、先頭の直後に3, 2を順番に追加していった。
なので、43行目の\texttt{display}関数で出力っされる値は\texttt{123}である。
次に\texttt{head}セルの次のセルを削除したので46行目の\texttt{display}関数では13が出力される。
最後に\texttt{delete\_cell\_top}関数を呼び出し、先頭のセルを削除したため、49行目での\texttt{display}関数では3のみが出力された。

\subsubsection{考察}

このコードだと、headの先頭にセルを追加する場合新しいリストを作る必要があります。
また、headのみ仕様が異なるので、余分に\texttt{insert\_cell\_top}メゾッドと\texttt{delete\_cell\_top}メゾッドを呼ぶ必要がありました。
それを踏まえると、ダミーのデータ部を持つheadを作成するほうが実装が単純になると考えられます。

\section{必須課題2-2}

\subsection{QueueArray.javaの作成}

\begin{figure}[t]
  \begin{center}
   \lstinputlisting[language=java,numbers=left]{QueueArray.java}
   \caption{QueueArray.javaのソースコード}
   \label{code:QueueArray}
  \end{center}
\end{figure}

\subsubsection{実装の方針}\label{sec:bs_impl_policy}
\texttt{QueueArray}クラスにはエンキューを行うための\texttt{enqueue}メゾッドとデキューを行うための\texttt{dequeue}。
キュー全体を表示する\texttt{display}メゾッドを作成した。そしてその動作を確認するための\texttt{main}メゾッドを作成する。

1. QueueArrayクラスのコンストラクタ

キューの作成に必要なものとしてコンストラクタで
整数の配列を表す\texttt{queue}、
格納できるメモリ量を表す長さを表す\texttt{length}、
キューの先頭を\texttt{front}
末尾を\texttt{rear}と定義した。

2. enqueueメゾッド

まずオーバーフローの処理を行う。もともとの配列Queueを超えるような値の挿入が起こってしまう可能性があるからだ。\\
オーバーフローしないことがわかったら要素の末尾に引数で指定した値を代入してrearに適切な処理を行う。

3. dequeueメゾッド

まずアンダーフローの処理を行う。それはキューの要素が存在しない場合にデキューを行わないようにするためである。\\
アンダーフローの処理後に要素の先頭の処理をしてその値を返すようにする。

4. displayメゾッド

要素の位置はコンストラクタで指定した\texttt{front}と\texttt{rear}をつかって表現することができるので、
その間の値を返すように実装を行う。

\subsubsection{実装コードおよびコードの説明}

\figref{code:QueueArray}QueueArray.javaのソースコードを示す．

\secref{sec:bs_impl_policy}で述べた，
\texttt{enqueue}メソッドと
\texttt{dequeue}メソッドは，それぞれ
14$\sim$21行目，
24$\sim$32行の部分に相当する．

\texttt{enqueue}
は末尾が配列の長さより大きくなる場合はオーバーフローとなり終了する。15$\sim$18行目でその実装をしている。\\
オーバーフローを起こす場合、\texttt{System.exit(1)}を書いて終了することができる。\\
オーバーフローを起こさない場合、\texttt{queue[rear]}が要素の末尾にあたるので
そこに引数として与えたint型の変数\texttt{val}を代入する。\\
キューのサイズを変えるためにrearの値を一つ上げる。そうすることで要素の末尾は右に一つずれたような挙動になる.

\texttt{dequeue}
は要素の中身がない場合はアンダーフローとなり終了する。
25$\sim$28行目でその実装をしている。frontとrearが等しいときに\texttt{dequeue}を行うと、アンダーフローになるので、その条件のときに\texttt{Queue Underflow!!}と出力して
先程と同様に\texttt{System.exit(1)}によりプログラムを終了させる。
デキューされるのは\texttt{queue[front]}であるのでその値を返す値である\texttt{x}に代入する。
引数の値を代入した後にfrontを一つ動かし要素を拡大する。

\subsubsection{実行結果}

\secref{sec:ls_code_exec}で述べたコンパイル方法と同様に，
QueueArray.javaを\texttt{javac}コマンドでコンパイルし，
QueueArray.classを生成する．その後，以下のコマンドを入力することによって，
QueueArray.javaのプログラムを実行する．

\begin{verbatim}
-------------------------------------
$ java QueueArray
12
1
2
-------------------------------------
\end{verbatim}

配列の長さが10のQUEUEを作成し、そこに順番に1, 2をエンキューする。
displayすると\texttt{12}が出力される。

デキューをすると1次に2が出力される。
この状態でデキューを行うとunderflow!が出力されて終了することも確認できた。

\subsubsection{考察}
\texttt{enqueue}メゾッドの計算量は\texttt{O(1)}であり、
\texttt{dequeue}メゾッドの計算量も\texttt{O(1)}である。
これはあらかじめ先頭と末尾の位置を変数で格納していることにより実現できた。

\section{発展課題2-3}

\subsection{双方向循環リストの作成}

\begin{figure}[t]
  \begin{center}
   \lstinputlisting[language=java,numbers=left]{No3/ListDL.java}
   \caption{ListDL.javaのソースコード1}
   \label{code:ListDL}
  \end{center}
\end{figure}

\begin{figure}[t]
  \begin{center}
   \lstinputlisting[language=java,numbers=left]{No3/ListDL.1.java}
   \caption{ListDL.javaのソースコード2}
   \label{code:ListDL}
  \end{center}
\end{figure}

\subsubsection{実装の方針}\label{sec:bs_impl_policy}

\texttt{ListDL}クラスには
次のポインタを表す\texttt{next}と
前のポインタを表す\texttt{prev}
値を表す\texttt{val}を定義する。
それらに対して以下の処理を行い実装をする。

1. コンストラクタ

はじめは循環するように\texttt{next}と\texttt{prev}の関係を作る。そのために、thisの次も前も指すポインタ部はthisになるように書く。
引数が与えられたときはその値を格納する。

2. insertNext, insertPrevメゾッド

引数となるリストをcellとおくと
前者はthis -> cell -> this.next\\
後者はthis.prev -> cell -> this\\
という位置関係になっている。
この２つの関係は３つのリストの位置関係というコードで共通するため、
\texttt{\_\_insertNext}で共通化してコードを実装する。

3. deleteメゾッド

this.prev -> this.nextの結びつけをおこない、その後thisを初期化する。
それぞれ\texttt{\_\_Delete}メゾッドと\texttt{initLinks}メゾッドを作成する。

4. searchメゾッド

コピーを作成し、ループさせる。データが引数と同じ場合にそのリストを返すように実装します。
またリストのループはポインタを移動していき、リストを一周してthisになった場合に終了する。
終了したらnullを返すように実装する。

5. displayメゾッド

4と同様のループ機構を書き、データ部をコマンドラインへ出力するようにする。

\subsubsection{実装コードおよびコードの説明}

\figref{code:ListDL}ListDL.javaのソースコードを示す．
\secref{sec:bs_impl_policy}で述べた，

\texttt{コンストラクタ}は6$\sim$13行目の部分に相当する．
headセルはデータ値を持たないようにするため、引数がない場合にはデータ値であるvalは定義しない。
そして、引数がある場合のコンストラクタにはデータ値を定義する。またどちらにも循環するようにリンクの初期化メゾッドを使っている。

\texttt{insertNext, insertPrev}メソッドは36$\sim$43行目の部分に相当する．
セルの前後にそれぞれ双方向にリストを結びつけるための４つコードがそれぞれ書かれている。

\texttt{delete}メソッドは46$\sim$49行目の部分に相当する．
セルの前後をリンク付ける。その後削除されたセルから前後のセルが呼び出せられるのを防ぐため、リンクの初期化を行う。

\texttt{search}メソッドは52$\sim$61行目の部分に相当する．
コピーを一周ループさせ、データの評価を行う。このときにコピーをポインタ部のセルにさせようにして終了条件をそのコピーがthisになったときにする。
そうすることでループの開始ではwhileの条件に含まれないようにしている。
データ値と引数が等しいときにそのリストを返す。
このループ中でこの条件を満たすものがない場合、nullを返す。

\texttt{display}メソッドは63$\sim$70行目の部分に相当する．
ループ機構は同じである。whileループの中でデータ値を出力している。
一周ループした後の69行目で改行をした。

このコードの確認のため、このクラス内に\texttt{main}メゾッドを実装した。
headをダミーセルとして1->2->5と表示できるようにリストを挿入する。

elemは\texttt{search}メゾッドを使うことで2->5->1というリストになる。
3を挿入して1->2->3->5のリストに、最後に5を削除して1->2->3というリストになることを想定している。

\subsubsection{実行結果}

\secref{sec:ls_code_exec}で述べたコンパイル方法と同様に，
ListDL.javaを\texttt{javac}コマンドでコンパイルし，
ListDL.classを生成する．その後，以下のコマンドを入力することによって，
ListDL.javaのプログラムを実行する．

\begin{verbatim}
-------------------------------------
$ java ListDL
12
1
2
-------------------------------------
\end{verbatim}
\subsubsection{考察}
\texttt{search}メゾッドの計算量は単純な線形探索を採用しているので\texttt{O(n)}である。
\texttt{insert, delete}メゾッドの計算量は\texttt{O(1)}である。

\section{必須課題2-4}

\subsection{双方向循環リストの改良}

\begin{figure}[t]
  \begin{center}
   \lstinputlisting[language=java,numbers=left]{ListDL.java}
   \caption{ListDL.javaのソースコード1}
   \label{code:ListDL}
  \end{center}
 \end{figure}

 \begin{figure}[t]
  \begin{center}
   \lstinputlisting[language=java,numbers=left]{ListDL.1.java}
   \caption{ListDL.javaのソースコード2}
   \label{code:ListDL}
  \end{center}
 \end{figure}

 
\begin{figure}[t]
  \begin{center}
   \lstinputlisting[language=java,numbers=left]{ListDLInt.java}
   \caption{ListDLInt.javaのソースコード}
   \label{code:ListDL}
  \end{center}
 \end{figure}

\subsubsection{実装の方針}\label{sec:bs_impl_policy}
ListDLIntはデータをint型にする。
ListDLのデータの型はObject型にした。これはどのような型に対しても代入可能にするためである。
その後に配列や外部ファイルからのリスト作成用メゾッドを実装する。

1. readFromArrayメゾッド

引数として受けとった配列を順にinsertする。

2. writeToArrayメゾッド

ループするごとにそのインデックスに応じた配列に格納する。
このときリスト数分の配列をさくせいするためにリストの長さを返すメゾッドlengthも作成する。

3. readFromFil, writeToFile、メゾッド

ファイルから一行ずつ読み込むコードを実装する。

\subsubsection{実装コードおよびコードの説明}

\figref{code:ListDL}ListDL.javaのソースコードを示す．
追加コードは75$\sim$143行目である。
リストをループするコードを少々改良した。
for文で実装することでコード行数を減らしている。
\texttt{readFromFile, writeToFile}メゾッドはBufferedWriterでファイルを開き、その後終了した後にメモリ管理のためにファイルを閉じる必要がある。
そのときにtry\_finally文を使った。これにより、エラーなどにも対応できる。

\subsubsection{実行結果}

動作を確認するコードListDLmain.javaを作成しました。
コードはいかに記す。
またwriteToArrayメゾッドの動作確認用のテキストファイル\texttt{array.txt}を作成した。
これらはこれまで同様ListDLmain.javaをコンパイルした後にいかのコマンドを実行する。

\begin{verbatim}
-------------------------------------
$ java ListDLmain
5 -> 1 -> 2 -> 
5 -> 3 -> 1 -> 2 -> 
3 -> 1 -> 2 -> 
1 -> 2 -> 3 -> 4 -> 5 -> 
12345
1357 -> 25 -> 262 -> 7224 -> 43 -> 63
-> 7747 -> 3622 -> 43 -> 4 -> 
-------------------------------------

out.txt------------------------------
3
1
2
-------------------------------------
\end{verbatim}

\begin{figure}[t]
  \begin{center}
   \lstinputlisting[language=java,numbers=left]{ListDLmain.java}
   \caption{ListDLmain.javaのソースコード}
   \label{code:ListDL}
  \end{center}
 \end{figure}

1. readFromArrayメゾッド

{1, 2, 3, 4, 5}の配列を作成して、それを引数として、readFromArrayメゾッドを呼び出したので、readedListには1 -> 2 -> 3 -> 4 -> 5が入っている。

2. writeToArrayメゾッド

foreach文でreadedListを配列として取り出したところ、12345が出力された。

3. readFromFileメゾッド

先程作成したarray.txtからのリストを表示したところ、

1357 -> 25 -> 262 -> 7224 -> 43 -> 63
-> 7747 -> 3622 -> 43 -> 4 -> 

と表示される。

4. writeToFileメゾッド

out.txtという引数で作成したところ想定道理の出力が行われた。

\subsubsection{考察}

この問題で２つの課題に直面しました。

１つ目は型の改良です。一つ前の課題での変数valをどの型にしようか迷いました。
調べたところ、ジェネリクスを用いた型の指定が多く出てきました。今回はこれまでで学んだ構文のみで継承を行おうと思ったので、Object型を使うことにしました。
これは型の決まっていないものなのでできるだけ利用を避けるべきです。なので外部のファイルではできるだけ使わないようなコードを心がけました。

2つ目はwriteToArrayメゾッドです。ここではうまく表現できずにObject型で返すようにしました。
ここは引数の型を判別して、それに対応した型を返すべきだと思いました。またリストに連番を振っていないためfor文に追加でCountという変数を用意して、リストに番号をつけました。
for文で複数の引数を持ったり、for文自体のインデックスを利用する方法が必要だと感じました。

\end{document}