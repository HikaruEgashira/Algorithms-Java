\documentclass[10.5pt,a4paper]{jsarticle}
\usepackage{graphicx}
\usepackage{amsmath}

\usepackage[final]{listings}
\usepackage{color}

\normalsize

\lstset{
  language=fortran,
  basicstyle=\ttfamily\scriptsize,
  commentstyle={\ttfamily \color[cmyk]{0,1,1,0}},
  keywordstyle={\bfseries \color[cmyk]{1,1,0,0}},
  stringstyle={\ttfamily \color[cmyk]{1,0,1,0.5}},
  stepnumber=1,
  numberstyle=\ttfamily,
  breaklines=true,
  breakindent=20pt,
  frame=tblr,
  framesep=4pt,
  tabsize=2
}

\newcommand{\figref}[1]{図\ref{#1}}
\newcommand{\tabref}[1]{表\ref{#1}}
\newcommand{\secref}[1]{\ref{#1}節}

\title{データ構造とアルゴリズム実験レポート\\課題１：\textless Javaによるプログラミングの復讐\textgreater}
\author{\textless 201811320\textgreater \textless 1クラス\textgreater \textless 江頭輝\textgreater}
\date{締切日：\textless 2019年4月22日\textgreater\\提出日：\textless 2019年4月21日\textgreater}

\begin{document}
\maketitle

\section{必須課題}

この課題では，教科書リスト1-1 (p.3) を基にした最大公約数を求めるJavaプログラムのGCDIter.javaを，教科書リスト1-4 (p.7) の「ユークリッドの互除法」に基づいたJavaプログラムGCDEuclid.javaを作成した，また作成したプログラムのリストおよび実行結果を示した．

\subsection{GCDEuclid.javaの作成}
\subsubsection{実装の方針}\label{sec:ls_impl_policy}
まず，\texttt{GCDEuclid}クラスを定義し，２つの引数を取ってユークリッドの互除法を用いて算出される最大公約数を返す\texttt{euclid}メソッドとして，\texttt{euclid}メゾッドを実行しその結果を表示するのを\texttt{main}メソッドとして，クラス内にそれぞれ実装した．また，\texttt{main}メソッドは，最大公約数を求める元となる二つの引数\texttt{n}と\texttt{m}をコマンドライン引数で渡すことによって動作する．このため，配列の長さと探索データに応じた探索時間の変化を調べるための実験が容易にできるようになった．また、assert文による確認コードを実装し事前にデバッグしやすくしました。

\subsubsection{実装コードおよびコードの説明}\label{sec:ls_impl_code}

\begin{figure}[t]
  \begin{center}
   \lstinputlisting[language=java,numbers=left]{GCDEuclid.java}
   \caption{GCDEuclid.javaのソースコード}
   \label{code:GCDEuclid}
  \end{center}
 \end{figure}

\figref{code:GCDEuclid}GCDEuclid.javaのソースコードを示す．\secref{sec:ls_impl_policy}で述べた，\texttt{euclid}メソッドと\texttt{main}メソッドは，それぞれ20$\sim$34行目，2$\sim$17行目の部分に相当する．

\texttt{euclid}メソッドは，\texttt{n}と\texttt{m}の最大公約数を求める。
割ったあまりがゼロになるまで繰り返し割り算を行うのがユークリッドの互除法だが、そのまえに割られる数が割る数より大きいことが前提条件としてある。なので、23$\sim$27行目でnがmより小さくなるように入れ替えを行っている。
28$\sim$32行目で実際にユークリッドの互除法を行った。
nをmで割った余りをrとしてn, mの値を更新している。
そして、余り（ここではm）がゼロになった時の割る数（ここではn）の値が最大公約数となる。

\texttt{main}メソッドは，\texttt{euclid}メソッドのテストケースとして機能する．
実際にassert分ではeuclidメゾッドを呼び出して、13673と31640の最大公約数が113になるかを確認する。求める対象である\texttt{n}および\texttt{m}は，コマンドライン引数によってセットされ，ソースコードの10，11行目がそれに相当する．\texttt{main}メソッドに渡せるコマンドライン引数の数は必ず2個であるようにするため，5$\sim$8行目でコマンドライン引数の配列数が二つでない場合は．"Usage: java GCDEuclid <int1> <int2>"というエラー文が帰ってきて実行が終了するように書かれている。
そのチェックの後、n, mにコマンドライン引数をわたし、13行目で\texttt{euclid}メゾッドを呼び出して変数gcdに最大公約数を渡す。
最後に"The GCD of "+ m +" and "+ n +" is "+ gcd +"."の形で最大公約数が出力される。

\subsubsection{実行結果}\label{sec:ls_code_exec}

まず，GCDEuclid.javaを以下のコマンドでコンパイルする．
\begin{verbatim}
-------------------------------------
$ javac -g -verbose GCDEuclid.java
-------------------------------------
\end{verbatim}
ここで，\texttt{-g}はデバッグ情報の付加させるためのオプション，\texttt{-verbose}はコンパイルの詳細な出力を表示させるためのオプションである．コンパイルが成功するとGCDEuclid.classが生成され，その後以下のコマンドを入力することによって，プログラムを実行できる．
\begin{verbatim}
-------------------------------------
$ java -ea GCDEuclid 57 76
The GCD of 76 and 57 is 19.
-------------------------------------
\end{verbatim}

57 と 76 の最大公約数を求める。すると、19と返ってきた。
57 = 19 × 3, 
76 = 19 × 4
であり確かに57 と 76の最大公約数は19なのでこのコードの挙動が正しいことが分かる。
\texttt{-ea}オプションはassert式を有効にするためのオプションであり、ここでもエラーは起こらなかった。

\subsubsection{考察}
最大公約数は、引数が自然数であることを前提とするため、自然数での確認のみにとどめておく。実際はバグを減らすために引数を自然数以外を受け付けないようにしなければならない。またこの時の実行時間はラメの定理より\texttt{O(log(n))}であることがわかる、これはよいアルゴリズムであるということなので最大公約数を求めるときはGCDIter.javaよりも推奨される書き方だということが分かる。30, 31行目の処理を減らすことでさらなる改善も期待できそうだ。

\section{発展課題}

\subsection{時間計算量}

この課題では，必須課題で作成したGCDIter.java，GCDEuclid.javaについて，それぞれの時間計算量を議論した．

一般的に，時間計算量はループにおける繰り返し回数によって左右されると言っても良い．GCDIter.javaでは，ループの繰り返し回数は，最小で1回，最大でn回となり，平均は約$n/2$回である．一回のループで2度の計算が行われ、$n$がパラメータであるので，計算量は$O(n)$となる．すなわち，$n$を大きくするにつれて，探索時間は線形に増加する．

一方，BinarySearch.javaでは，ラメの定理よりnの桁数の訳5倍桁数は$logn$で表すので，平均は約$logn$回である．これも$n$がパラメータであることに変わりはないので，計算量は$O(logn)$となる．このことからも計算量が格段に減ることが分かる。

\subsection{GCDRecursive.javaの作成}

\begin{figure}[t]
  \begin{center}
   \lstinputlisting[language=java,numbers=left]{GCDRecursive.java}
   \caption{GCDRecursive.javaのソースコード}
   \label{code:GCDRecursive}
  \end{center}
 \end{figure}

\subsubsection{実装の方針}\label{sec:bs_impl_policy}
実装の方針は，GCDEuclid.javaと同様である．余り（m）がゼロになった時を終了条件とする再帰メゾッドを実装する。
前回と同様にnがmより小さくなるような入れ替えをおこなったあと、
nをmで割った余りをrとおく。
recursiveメゾッドを返すことでｍがゼロになるまでループし続ける。

\subsubsection{実装コードおよびコードの説明}

\figref{code:GCDRecursive}GCDRecursive.javaのソースコードを示す．\secref{sec:bs_impl_policy}で述べた，\texttt{recursive}メソッドと\texttt{main}メソッドは，それぞれ19$\sim$31行目，2$\sim$16行の部分に相当する．
今回はデバッグのスピードを速めるために、コマンドライン引数がない場合はnに13673をmに31640を代入させるようにした。本番環境ではコメントアウトすることが望ましい。
\texttt{recursive}メゾッドは再帰メゾッドなのではじめに終了条件のmがゼロの時を書き、そこでnを最大公約数として返すようにしている。
24$\sim$28行目で入れ替えを行った後、rにnとmのあまりを代入して、mとrで再帰させている。

\subsubsection{実行結果}

\secref{sec:ls_code_exec}で述べたコンパイル方法と同様に，GCDRecursive.javaを\texttt{javac}コマンドでコンパイルし，GCDRecursive.classを生成する．その後，以下のコマンドを入力することによって，GCDRecursive.javaのプログラムを実行する．
\begin{verbatim}
-------------------------------------
$ java -ea GCDRecursive 57 76
The GCD of 76 and 57 is 19.
-------------------------------------
\end{verbatim}

\subsubsection{考察}

30行目の再帰させるときnのところにm, mのところにrを引数とすることで、前回のGCDEuclid.javaで行った
値の最代入を省略している。
それにより、計算量は同じ\texttt{O(log(n)}だが多少の改善が行われたと思う。

\end{document}
